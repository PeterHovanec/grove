"use strict";class t{constructor(e={key:"",node:null},r=!1){if(!(r||e.key&&"string"==typeof e.key))throw new Error("Parent key cannot be null, empty or not type of string!");if(!(r||e.node&&e.node instanceof t))throw new Error("Parent node cannot be null, empty or not class of TrieNode");this._parent=e,this._children={},this.data=null,this.isEndOfWord=!1,this.word=null}get parent(){return this._parent}get children(){return this._children}update(t){this.isEndOfWord=!!t,this.data=t,this.isEndOfWord||(this.word=null)}unlink(){this._parent={key:"",node:null}}hasChildren(){return Object.keys(this._children).length>0}deleteChild(t){this._children[t]&&(this._children[t].update(null),this._children[t].unlink(),this._children[t].word=null,delete this._children[t])}addChild(t,e){if(!t||!e)return null;const r=this._children[t];return this._children[t]=e,r}hasChild(t){return!!this._children[t]}}class e{constructor(t){this.value=t,this.children=[],this.parent=null}addChild(t){t.parent=this,this.children.push(t)}removeChild(t){const e=this.children.indexOf(t);e>-1&&(this.children.splice(e,1),t.parent=null)}getChildAt(t){return this.children[t]}getChildrenCount(){return this.children.length}findChild(t){return this.children.find((e=>e.value===t))||null}getSiblings(){return this.parent?this.parent.children.filter((t=>t!==this)):[]}}exports.OrdinalNode=e,exports.OrdinalTree=class{constructor(){this.root=null}add(t,r=null){const n=new e(t);if(null===this.root)this.root=n;else{const t=this.findNode(this.root,r);if(!t)return;t.addChild(n)}}findNode(t,e){if(t.value===e)return t;for(const r of t.children){const t=this.findNode(r,e);if(t)return t}return null}traverse(t){const e=r=>{t(r),r.children.forEach(e)};this.root&&e(this.root)}remove(t){const e=this.findNode(this.root,t);e&&e.parent?e.parent.removeChild(e):e===this.root&&(this.root=null)}getHeight(){const t=e=>{if(!e)return-1;const r=e.children.map(t);return 1+Math.max(-1,...r)};return t(this.root)}getAllValues(){const t=[];return this.traverse((e=>t.push(e.value))),t}findNodeWithCallback(t){const e=r=>{if(t(r))return r;for(const t of r.children){const r=e(t);if(r)return r}return null};return e(this.root)}},exports.Trie=class{constructor(){this._root=new t(null,!0),this._lastIndex=1}get root(){return this._root}insert(t,e){return this._insertWord(t,e,this._root,0)}_insertWord(e,r,n,i){if(i===e.length)return n.word=e,n.update(r||this._getNextIndex()),!0;let s=e.charAt(i);return n.hasChild(s)||n.addChild(s,new t({key:s,node:n})),this._insertWord(e,r,n.children[s],i+1)}search(t){const e=this._searchNode(t,this._root,0);return e?e.data:null}_searchNode(t,e,r){if(r===t.length)return e.isEndOfWord?e:null;let n=t.charAt(r);return e.hasChild(n)?this._searchNode(t,e.children[n],r+1):null}delete(t){const e=this._searchNode(t,this._root,0);return!!e&&(e.hasChildren()?(e.update(null),!0):(this._deleteWord(e),!0))}_deleteWord(t){if(t===this._root)return;const e=t.parent;e.node.deleteChild(e.key),e.node.hasChildren()||this._deleteWord(e.node)}update(t,e){const r=this._searchNode(t,this._root,0);return!!r&&(r.update(e),!0)}getDataNode(t){return this._searchNode(t,this._root,0)}getPath(t){const e=[];e.push(this._root);for(let r=1;r<=t.length;r++)e.push(this._searchNode(t.substring(0,r),this._root,0));return e}_getNextIndex(){return this._lastIndex++}},exports.TrieNode=t;
//# sourceMappingURL=grove.js.map
